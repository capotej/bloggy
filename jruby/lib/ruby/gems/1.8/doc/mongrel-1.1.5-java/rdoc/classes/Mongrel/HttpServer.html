<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: Mongrel::HttpServer</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">Mongrel::HttpServer</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../files/lib/mongrel_rb.html">
                lib/mongrel.rb
                </a>
        <br />
                <a href="../../files/lib/mongrel_rb.html">
                lib/mongrel.rb
                </a>
        <br />
            </td>
        </tr>

        <tr class="top-aligned-row">
            <td><strong>Parent:</strong></td>
            <td>
                Object
            </td>
        </tr>
        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
This is the main driver of <a href="../Mongrel.html">Mongrel</a>, while the
<a href="HttpParser.html">Mongrel::HttpParser</a> and <a
href="URIClassifier.html">Mongrel::URIClassifier</a> make up the majority
of how the server functions. It&#8216;s a very simple class that just has a
thread accepting connections and a simple <a
href="HttpServer.html#M000084">HttpServer.process_client</a> function to do
the heavy lifting with the <a href="../IO.html">IO</a> and Ruby.
</p>
<p>
You use it by doing the following:
</p>
<pre>
  server = HttpServer.new(&quot;0.0.0.0&quot;, 3000)
  server.register(&quot;/stuff&quot;, MyNiftyHandler.new)
  server.run.join
</pre>
<p>
The last line can be just server.run if you don&#8216;t want to join the
thread used. If you don&#8216;t though Ruby will mysteriously just exit on
you.
</p>
<p>
Ruby&#8216;s thread implementation is &quot;interesting&quot; to say the
least. Experiments with <b>many</b> different types of <a
href="../IO.html">IO</a> processing simply cannot make a dent in it. Future
releases of <a href="../Mongrel.html">Mongrel</a> will find other creative
ways to make threads faster, but don&#8216;t hold your breath until Ruby
1.9 is actually finally useful.
</p>

    </div>


   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000096">configure_socket_options</a>&nbsp;&nbsp;
      <a href="#M000087">configure_socket_options</a>&nbsp;&nbsp;
      <a href="#M000086">graceful_shutdown</a>&nbsp;&nbsp;
      <a href="#M000095">graceful_shutdown</a>&nbsp;&nbsp;
      <a href="#M000092">new</a>&nbsp;&nbsp;
      <a href="#M000083">new</a>&nbsp;&nbsp;
      <a href="#M000084">process_client</a>&nbsp;&nbsp;
      <a href="#M000093">process_client</a>&nbsp;&nbsp;
      <a href="#M000085">reap_dead_workers</a>&nbsp;&nbsp;
      <a href="#M000094">reap_dead_workers</a>&nbsp;&nbsp;
      <a href="#M000089">register</a>&nbsp;&nbsp;
      <a href="#M000098">register</a>&nbsp;&nbsp;
      <a href="#M000088">run</a>&nbsp;&nbsp;
      <a href="#M000097">run</a>&nbsp;&nbsp;
      <a href="#M000091">stop</a>&nbsp;&nbsp;
      <a href="#M000100">stop</a>&nbsp;&nbsp;
      <a href="#M000090">unregister</a>&nbsp;&nbsp;
      <a href="#M000099">unregister</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">





    <div id="attribute-list">
      <h3 class="section-bar">Attributes</h3>

      <div class="name-list">
        <table>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">acceptor</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">acceptor</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">classifier</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">classifier</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">host</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">host</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">num_processors</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">num_processors</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">port</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">port</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">throttle</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">throttle</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">timeout</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">timeout</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">workers</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">workers</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        </table>
      </div>
    </div>
      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Class methods</h3>

      <div id="method-M000092" class="method-detail">
        <a name="M000092"></a>

        <div class="method-heading">
          <a href="#M000092" class="method-signature">
          <span class="method-name">new</span><span class="method-args">(host, port, num_processors=950, throttle=0, timeout=60)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Creates a working server on host:port (strange things happen if port
isn&#8216;t a Number). Use HttpServer::run to start the server and
HttpServer.acceptor.join to join the thread that&#8216;s processing
incoming requests on the socket.
</p>
<p>
The num_processors optional argument is the maximum number of concurrent
processors to accept, anything over this is closed immediately to maintain
server processing performance. This may seem mean but it is the most
efficient way to deal with overload. Other schemes involve still parsing
the client&#8216;s request which defeats the point of an overload handling
system.
</p>
<p>
The throttle parameter is a sleep timeout (in hundredths of a second) that
is placed between socket.accept calls in order to give the server a cheap
throttle time. It defaults to 0 and actually if it is 0 then the sleep is
not done at all.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000092-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000092-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 90</span>
 90:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>, <span class="ruby-identifier">num_processors</span>=<span class="ruby-value">950</span>, <span class="ruby-identifier">throttle</span>=<span class="ruby-value">0</span>, <span class="ruby-identifier">timeout</span>=<span class="ruby-value">60</span>)
 91:       
 92:       <span class="ruby-identifier">tries</span> = <span class="ruby-value">0</span>
 93:       <span class="ruby-ivar">@socket</span> = <span class="ruby-constant">TCPServer</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>) 
 94:       
 95:       <span class="ruby-ivar">@classifier</span> = <span class="ruby-constant">URIClassifier</span>.<span class="ruby-identifier">new</span>
 96:       <span class="ruby-ivar">@host</span> = <span class="ruby-identifier">host</span>
 97:       <span class="ruby-ivar">@port</span> = <span class="ruby-identifier">port</span>
 98:       <span class="ruby-ivar">@workers</span> = <span class="ruby-constant">ThreadGroup</span>.<span class="ruby-identifier">new</span>
 99:       <span class="ruby-ivar">@throttle</span> = <span class="ruby-identifier">throttle</span> <span class="ruby-operator">/</span> <span class="ruby-value">100.0</span>
100:       <span class="ruby-ivar">@num_processors</span> = <span class="ruby-identifier">num_processors</span>
101:       <span class="ruby-ivar">@timeout</span> = <span class="ruby-identifier">timeout</span>
102:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000083" class="method-detail">
        <a name="M000083"></a>

        <div class="method-heading">
          <a href="#M000083" class="method-signature">
          <span class="method-name">new</span><span class="method-args">(host, port, num_processors=950, throttle=0, timeout=60)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Creates a working server on host:port (strange things happen if port
isn&#8216;t a Number). Use HttpServer::run to start the server and
HttpServer.acceptor.join to join the thread that&#8216;s processing
incoming requests on the socket.
</p>
<p>
The num_processors optional argument is the maximum number of concurrent
processors to accept, anything over this is closed immediately to maintain
server processing performance. This may seem mean but it is the most
efficient way to deal with overload. Other schemes involve still parsing
the client&#8216;s request which defeats the point of an overload handling
system.
</p>
<p>
The throttle parameter is a sleep timeout (in hundredths of a second) that
is placed between socket.accept calls in order to give the server a cheap
throttle time. It defaults to 0 and actually if it is 0 then the sleep is
not done at all.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000083-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000083-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 90</span>
 90:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>, <span class="ruby-identifier">num_processors</span>=<span class="ruby-value">950</span>, <span class="ruby-identifier">throttle</span>=<span class="ruby-value">0</span>, <span class="ruby-identifier">timeout</span>=<span class="ruby-value">60</span>)
 91:       
 92:       <span class="ruby-identifier">tries</span> = <span class="ruby-value">0</span>
 93:       <span class="ruby-ivar">@socket</span> = <span class="ruby-constant">TCPServer</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>) 
 94:       
 95:       <span class="ruby-ivar">@classifier</span> = <span class="ruby-constant">URIClassifier</span>.<span class="ruby-identifier">new</span>
 96:       <span class="ruby-ivar">@host</span> = <span class="ruby-identifier">host</span>
 97:       <span class="ruby-ivar">@port</span> = <span class="ruby-identifier">port</span>
 98:       <span class="ruby-ivar">@workers</span> = <span class="ruby-constant">ThreadGroup</span>.<span class="ruby-identifier">new</span>
 99:       <span class="ruby-ivar">@throttle</span> = <span class="ruby-identifier">throttle</span> <span class="ruby-operator">/</span> <span class="ruby-value">100.0</span>
100:       <span class="ruby-ivar">@num_processors</span> = <span class="ruby-identifier">num_processors</span>
101:       <span class="ruby-ivar">@timeout</span> = <span class="ruby-identifier">timeout</span>
102:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000096" class="method-detail">
        <a name="M000096"></a>

        <div class="method-heading">
          <a href="#M000096" class="method-signature">
          <span class="method-name">configure_socket_options</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000096-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000096-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 240</span>
240:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">configure_socket_options</span>
241:       <span class="ruby-keyword kw">case</span> <span class="ruby-constant">RUBY_PLATFORM</span>
242:       <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/linux/</span>
243:         <span class="ruby-comment cmt"># 9 is currently TCP_DEFER_ACCEPT</span>
244:         <span class="ruby-identifier">$tcp_defer_accept_opts</span> = [<span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">SOL_TCP</span>, <span class="ruby-value">9</span>, <span class="ruby-value">1</span>]
245:         <span class="ruby-identifier">$tcp_cork_opts</span> = [<span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">SOL_TCP</span>, <span class="ruby-value">3</span>, <span class="ruby-value">1</span>]
246:       <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/freebsd(([1-4]\..{1,2})|5\.[0-4])/</span>
247:         <span class="ruby-comment cmt"># Do nothing, just closing a bug when freebsd &lt;= 5.4</span>
248:       <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/freebsd/</span>
249:         <span class="ruby-comment cmt"># Use the HTTP accept filter if available.</span>
250:         <span class="ruby-comment cmt"># The struct made by pack() is defined in /usr/include/sys/socket.h as accept_filter_arg</span>
251:         <span class="ruby-keyword kw">unless</span> <span class="ruby-value">`/sbin/sysctl -nq net.inet.accf.http`</span>.<span class="ruby-identifier">empty?</span>
252:           <span class="ruby-identifier">$tcp_defer_accept_opts</span> = [<span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">SOL_SOCKET</span>, <span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">SO_ACCEPTFILTER</span>, [<span class="ruby-value str">'httpready'</span>, <span class="ruby-keyword kw">nil</span>].<span class="ruby-identifier">pack</span>(<span class="ruby-value str">'a16a240'</span>)]
253:         <span class="ruby-keyword kw">end</span>
254:       <span class="ruby-keyword kw">end</span>
255:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000087" class="method-detail">
        <a name="M000087"></a>

        <div class="method-heading">
          <a href="#M000087" class="method-signature">
          <span class="method-name">configure_socket_options</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000087-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000087-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 240</span>
240:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">configure_socket_options</span>
241:       <span class="ruby-keyword kw">case</span> <span class="ruby-constant">RUBY_PLATFORM</span>
242:       <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/linux/</span>
243:         <span class="ruby-comment cmt"># 9 is currently TCP_DEFER_ACCEPT</span>
244:         <span class="ruby-identifier">$tcp_defer_accept_opts</span> = [<span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">SOL_TCP</span>, <span class="ruby-value">9</span>, <span class="ruby-value">1</span>]
245:         <span class="ruby-identifier">$tcp_cork_opts</span> = [<span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">SOL_TCP</span>, <span class="ruby-value">3</span>, <span class="ruby-value">1</span>]
246:       <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/freebsd(([1-4]\..{1,2})|5\.[0-4])/</span>
247:         <span class="ruby-comment cmt"># Do nothing, just closing a bug when freebsd &lt;= 5.4</span>
248:       <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/freebsd/</span>
249:         <span class="ruby-comment cmt"># Use the HTTP accept filter if available.</span>
250:         <span class="ruby-comment cmt"># The struct made by pack() is defined in /usr/include/sys/socket.h as accept_filter_arg</span>
251:         <span class="ruby-keyword kw">unless</span> <span class="ruby-value">`/sbin/sysctl -nq net.inet.accf.http`</span>.<span class="ruby-identifier">empty?</span>
252:           <span class="ruby-identifier">$tcp_defer_accept_opts</span> = [<span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">SOL_SOCKET</span>, <span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">SO_ACCEPTFILTER</span>, [<span class="ruby-value str">'httpready'</span>, <span class="ruby-keyword kw">nil</span>].<span class="ruby-identifier">pack</span>(<span class="ruby-value str">'a16a240'</span>)]
253:         <span class="ruby-keyword kw">end</span>
254:       <span class="ruby-keyword kw">end</span>
255:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000086" class="method-detail">
        <a name="M000086"></a>

        <div class="method-heading">
          <a href="#M000086" class="method-signature">
          <span class="method-name">graceful_shutdown</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Performs a wait on all the currently running threads and kills any that
take too long. It waits by @timeout seconds, which can be set in
.initialize or via mongrel_rails. The @throttle setting does extend this
waiting period by that much longer.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000086-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000086-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 233</span>
233:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">graceful_shutdown</span>
234:       <span class="ruby-keyword kw">while</span> <span class="ruby-identifier">reap_dead_workers</span>(<span class="ruby-value str">&quot;shutdown&quot;</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
235:         <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Waiting for #{@workers.list.length} requests to finish, could take #{@timeout + @throttle} seconds.&quot;</span>
236:         <span class="ruby-identifier">sleep</span> <span class="ruby-ivar">@timeout</span> <span class="ruby-operator">/</span> <span class="ruby-value">10</span>
237:       <span class="ruby-keyword kw">end</span>
238:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000095" class="method-detail">
        <a name="M000095"></a>

        <div class="method-heading">
          <a href="#M000095" class="method-signature">
          <span class="method-name">graceful_shutdown</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Performs a wait on all the currently running threads and kills any that
take too long. It waits by @timeout seconds, which can be set in
.initialize or via mongrel_rails. The @throttle setting does extend this
waiting period by that much longer.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000095-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000095-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 233</span>
233:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">graceful_shutdown</span>
234:       <span class="ruby-keyword kw">while</span> <span class="ruby-identifier">reap_dead_workers</span>(<span class="ruby-value str">&quot;shutdown&quot;</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
235:         <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Waiting for #{@workers.list.length} requests to finish, could take #{@timeout + @throttle} seconds.&quot;</span>
236:         <span class="ruby-identifier">sleep</span> <span class="ruby-ivar">@timeout</span> <span class="ruby-operator">/</span> <span class="ruby-value">10</span>
237:       <span class="ruby-keyword kw">end</span>
238:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000084" class="method-detail">
        <a name="M000084"></a>

        <div class="method-heading">
          <a href="#M000084" class="method-signature">
          <span class="method-name">process_client</span><span class="method-args">(client)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Does the majority of the <a href="../IO.html">IO</a> processing. It has
been written in Ruby using about 7 different <a href="../IO.html">IO</a>
processing strategies and no matter how it&#8216;s done the performance
just does not improve. It is currently carefully constructed to make sure
that it gets the best possible performance, but anyone who thinks they can
make it faster is more than welcome to take a crack at it.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000084-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000084-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 109</span>
109:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">process_client</span>(<span class="ruby-identifier">client</span>)
110:       <span class="ruby-keyword kw">begin</span>
111:         <span class="ruby-identifier">parser</span> = <span class="ruby-constant">HttpParser</span>.<span class="ruby-identifier">new</span>
112:         <span class="ruby-identifier">params</span> = <span class="ruby-constant">HttpParams</span>.<span class="ruby-identifier">new</span>
113:         <span class="ruby-identifier">request</span> = <span class="ruby-keyword kw">nil</span>
114:         <span class="ruby-identifier">data</span> = <span class="ruby-identifier">client</span>.<span class="ruby-identifier">readpartial</span>(<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">CHUNK_SIZE</span>)
115:         <span class="ruby-identifier">nparsed</span> = <span class="ruby-value">0</span>
116: 
117:         <span class="ruby-comment cmt"># Assumption: nparsed will always be less since data will get filled with more</span>
118:         <span class="ruby-comment cmt"># after each parsing.  If it doesn't get more then there was a problem</span>
119:         <span class="ruby-comment cmt"># with the read operation on the client socket.  Effect is to stop processing when the</span>
120:         <span class="ruby-comment cmt"># socket can't fill the buffer for further parsing.</span>
121:         <span class="ruby-keyword kw">while</span> <span class="ruby-identifier">nparsed</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">length</span>
122:           <span class="ruby-identifier">nparsed</span> = <span class="ruby-identifier">parser</span>.<span class="ruby-identifier">execute</span>(<span class="ruby-identifier">params</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">nparsed</span>)
123: 
124:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">parser</span>.<span class="ruby-identifier">finished?</span>
125:             <span class="ruby-keyword kw">if</span> <span class="ruby-keyword kw">not</span> <span class="ruby-identifier">params</span>[<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">REQUEST_PATH</span>]
126:               <span class="ruby-comment cmt"># it might be a dumbass full host request header</span>
127:               <span class="ruby-identifier">uri</span> = <span class="ruby-constant">URI</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">params</span>[<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">REQUEST_URI</span>])
128:               <span class="ruby-identifier">params</span>[<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">REQUEST_PATH</span>] = <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">path</span>
129:             <span class="ruby-keyword kw">end</span>
130: 
131:             <span class="ruby-identifier">raise</span> <span class="ruby-value str">&quot;No REQUEST PATH&quot;</span> <span class="ruby-keyword kw">if</span> <span class="ruby-keyword kw">not</span> <span class="ruby-identifier">params</span>[<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">REQUEST_PATH</span>]
132: 
133:             <span class="ruby-identifier">script_name</span>, <span class="ruby-identifier">path_info</span>, <span class="ruby-identifier">handlers</span> = <span class="ruby-ivar">@classifier</span>.<span class="ruby-identifier">resolve</span>(<span class="ruby-identifier">params</span>[<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">REQUEST_PATH</span>])
134: 
135:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">handlers</span>
136:               <span class="ruby-identifier">params</span>[<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">PATH_INFO</span>] = <span class="ruby-identifier">path_info</span>
137:               <span class="ruby-identifier">params</span>[<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">SCRIPT_NAME</span>] = <span class="ruby-identifier">script_name</span>
138: 
139:               <span class="ruby-comment cmt"># From http://www.ietf.org/rfc/rfc3875 :</span>
140:               <span class="ruby-comment cmt"># &quot;Script authors should be aware that the REMOTE_ADDR and REMOTE_HOST</span>
141:               <span class="ruby-comment cmt">#  meta-variables (see sections 4.1.8 and 4.1.9) may not identify the</span>
142:               <span class="ruby-comment cmt">#  ultimate source of the request.  They identify the client for the</span>
143:               <span class="ruby-comment cmt">#  immediate request to the server; that client may be a proxy, gateway,</span>
144:               <span class="ruby-comment cmt">#  or other intermediary acting on behalf of the actual source client.&quot;</span>
145:               <span class="ruby-identifier">params</span>[<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">REMOTE_ADDR</span>] = <span class="ruby-identifier">client</span>.<span class="ruby-identifier">peeraddr</span>.<span class="ruby-identifier">last</span>
146: 
147:               <span class="ruby-comment cmt"># select handlers that want more detailed request notification</span>
148:               <span class="ruby-identifier">notifiers</span> = <span class="ruby-identifier">handlers</span>.<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">h</span><span class="ruby-operator">|</span> <span class="ruby-identifier">h</span>.<span class="ruby-identifier">request_notify</span> }
149:               <span class="ruby-identifier">request</span> = <span class="ruby-constant">HttpRequest</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">params</span>, <span class="ruby-identifier">client</span>, <span class="ruby-identifier">notifiers</span>)
150: 
151:               <span class="ruby-comment cmt"># in the case of large file uploads the user could close the socket, so skip those requests</span>
152:               <span class="ruby-keyword kw">break</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">request</span>.<span class="ruby-identifier">body</span> <span class="ruby-operator">==</span> <span class="ruby-keyword kw">nil</span>  <span class="ruby-comment cmt"># nil signals from HttpRequest::initialize that the request was aborted</span>
153: 
154:               <span class="ruby-comment cmt"># request is good so far, continue processing the response</span>
155:               <span class="ruby-identifier">response</span> = <span class="ruby-constant">HttpResponse</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">client</span>)
156: 
157:               <span class="ruby-comment cmt"># Process each handler in registered order until we run out or one finalizes the response.</span>
158:               <span class="ruby-identifier">handlers</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">handler</span><span class="ruby-operator">|</span>
159:                 <span class="ruby-identifier">handler</span>.<span class="ruby-identifier">process</span>(<span class="ruby-identifier">request</span>, <span class="ruby-identifier">response</span>)
160:                 <span class="ruby-keyword kw">break</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">response</span>.<span class="ruby-identifier">done</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">client</span>.<span class="ruby-identifier">closed?</span>
161:               <span class="ruby-keyword kw">end</span>
162: 
163:               <span class="ruby-comment cmt"># And finally, if nobody closed the response off, we finalize it.</span>
164:               <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">response</span>.<span class="ruby-identifier">done</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">client</span>.<span class="ruby-identifier">closed?</span> 
165:                 <span class="ruby-identifier">response</span>.<span class="ruby-identifier">finished</span>
166:               <span class="ruby-keyword kw">end</span>
167:             <span class="ruby-keyword kw">else</span>
168:               <span class="ruby-comment cmt"># Didn't find it, return a stock 404 response.</span>
169:               <span class="ruby-identifier">client</span>.<span class="ruby-identifier">write</span>(<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">ERROR_404_RESPONSE</span>)
170:             <span class="ruby-keyword kw">end</span>
171: 
172:             <span class="ruby-keyword kw">break</span> <span class="ruby-comment cmt">#done</span>
173:           <span class="ruby-keyword kw">else</span>
174:             <span class="ruby-comment cmt"># Parser is not done, queue up more data to read and continue parsing</span>
175:             <span class="ruby-identifier">chunk</span> = <span class="ruby-identifier">client</span>.<span class="ruby-identifier">readpartial</span>(<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">CHUNK_SIZE</span>)
176:             <span class="ruby-keyword kw">break</span> <span class="ruby-keyword kw">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">chunk</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">chunk</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>  <span class="ruby-comment cmt"># read failed, stop processing</span>
177: 
178:             <span class="ruby-identifier">data</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">chunk</span>
179:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">MAX_HEADER</span>
180:               <span class="ruby-identifier">raise</span> <span class="ruby-constant">HttpParserError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value str">&quot;HEADER is longer than allowed, aborting client early.&quot;</span>)
181:             <span class="ruby-keyword kw">end</span>
182:           <span class="ruby-keyword kw">end</span>
183:         <span class="ruby-keyword kw">end</span>
184:       <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">EOFError</span>,<span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">ECONNRESET</span>,<span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">EPIPE</span>,<span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">EINVAL</span>,<span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">EBADF</span>
185:         <span class="ruby-identifier">client</span>.<span class="ruby-identifier">close</span> <span class="ruby-keyword kw">rescue</span> <span class="ruby-keyword kw">nil</span>
186:       <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">HttpParserError</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
187:         <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{Time.now}: HTTP parse error, malformed request (#{params[Const::HTTP_X_FORWARDED_FOR] || client.peeraddr.last}): #{e.inspect}&quot;</span>
188:         <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{Time.now}: REQUEST DATA: #{data.inspect}\n---\nPARAMS: #{params.inspect}\n---\n&quot;</span>
189:       <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">EMFILE</span>
190:         <span class="ruby-identifier">reap_dead_workers</span>(<span class="ruby-value str">'too many files'</span>)
191:       <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">Object</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
192:         <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{Time.now}: Read error: #{e.inspect}&quot;</span>
193:         <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">backtrace</span>.<span class="ruby-identifier">join</span>(<span class="ruby-value str">&quot;\n&quot;</span>)
194:       <span class="ruby-keyword kw">ensure</span>
195:         <span class="ruby-keyword kw">begin</span>
196:           <span class="ruby-identifier">client</span>.<span class="ruby-identifier">close</span>
197:         <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">IOError</span>
198:           <span class="ruby-comment cmt"># Already closed</span>
199:         <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">Object</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
200:           <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{Time.now}: Client error: #{e.inspect}&quot;</span>
201:           <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">backtrace</span>.<span class="ruby-identifier">join</span>(<span class="ruby-value str">&quot;\n&quot;</span>)
202:         <span class="ruby-keyword kw">end</span>
203:         <span class="ruby-identifier">request</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">delete</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">request</span> <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">request</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Tempfile</span>
204:       <span class="ruby-keyword kw">end</span>
205:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000093" class="method-detail">
        <a name="M000093"></a>

        <div class="method-heading">
          <a href="#M000093" class="method-signature">
          <span class="method-name">process_client</span><span class="method-args">(client)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Does the majority of the <a href="../IO.html">IO</a> processing. It has
been written in Ruby using about 7 different <a href="../IO.html">IO</a>
processing strategies and no matter how it&#8216;s done the performance
just does not improve. It is currently carefully constructed to make sure
that it gets the best possible performance, but anyone who thinks they can
make it faster is more than welcome to take a crack at it.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000093-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000093-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 109</span>
109:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">process_client</span>(<span class="ruby-identifier">client</span>)
110:       <span class="ruby-keyword kw">begin</span>
111:         <span class="ruby-identifier">parser</span> = <span class="ruby-constant">HttpParser</span>.<span class="ruby-identifier">new</span>
112:         <span class="ruby-identifier">params</span> = <span class="ruby-constant">HttpParams</span>.<span class="ruby-identifier">new</span>
113:         <span class="ruby-identifier">request</span> = <span class="ruby-keyword kw">nil</span>
114:         <span class="ruby-identifier">data</span> = <span class="ruby-identifier">client</span>.<span class="ruby-identifier">readpartial</span>(<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">CHUNK_SIZE</span>)
115:         <span class="ruby-identifier">nparsed</span> = <span class="ruby-value">0</span>
116: 
117:         <span class="ruby-comment cmt"># Assumption: nparsed will always be less since data will get filled with more</span>
118:         <span class="ruby-comment cmt"># after each parsing.  If it doesn't get more then there was a problem</span>
119:         <span class="ruby-comment cmt"># with the read operation on the client socket.  Effect is to stop processing when the</span>
120:         <span class="ruby-comment cmt"># socket can't fill the buffer for further parsing.</span>
121:         <span class="ruby-keyword kw">while</span> <span class="ruby-identifier">nparsed</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">length</span>
122:           <span class="ruby-identifier">nparsed</span> = <span class="ruby-identifier">parser</span>.<span class="ruby-identifier">execute</span>(<span class="ruby-identifier">params</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">nparsed</span>)
123: 
124:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">parser</span>.<span class="ruby-identifier">finished?</span>
125:             <span class="ruby-keyword kw">if</span> <span class="ruby-keyword kw">not</span> <span class="ruby-identifier">params</span>[<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">REQUEST_PATH</span>]
126:               <span class="ruby-comment cmt"># it might be a dumbass full host request header</span>
127:               <span class="ruby-identifier">uri</span> = <span class="ruby-constant">URI</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">params</span>[<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">REQUEST_URI</span>])
128:               <span class="ruby-identifier">params</span>[<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">REQUEST_PATH</span>] = <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">path</span>
129:             <span class="ruby-keyword kw">end</span>
130: 
131:             <span class="ruby-identifier">raise</span> <span class="ruby-value str">&quot;No REQUEST PATH&quot;</span> <span class="ruby-keyword kw">if</span> <span class="ruby-keyword kw">not</span> <span class="ruby-identifier">params</span>[<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">REQUEST_PATH</span>]
132: 
133:             <span class="ruby-identifier">script_name</span>, <span class="ruby-identifier">path_info</span>, <span class="ruby-identifier">handlers</span> = <span class="ruby-ivar">@classifier</span>.<span class="ruby-identifier">resolve</span>(<span class="ruby-identifier">params</span>[<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">REQUEST_PATH</span>])
134: 
135:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">handlers</span>
136:               <span class="ruby-identifier">params</span>[<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">PATH_INFO</span>] = <span class="ruby-identifier">path_info</span>
137:               <span class="ruby-identifier">params</span>[<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">SCRIPT_NAME</span>] = <span class="ruby-identifier">script_name</span>
138: 
139:               <span class="ruby-comment cmt"># From http://www.ietf.org/rfc/rfc3875 :</span>
140:               <span class="ruby-comment cmt"># &quot;Script authors should be aware that the REMOTE_ADDR and REMOTE_HOST</span>
141:               <span class="ruby-comment cmt">#  meta-variables (see sections 4.1.8 and 4.1.9) may not identify the</span>
142:               <span class="ruby-comment cmt">#  ultimate source of the request.  They identify the client for the</span>
143:               <span class="ruby-comment cmt">#  immediate request to the server; that client may be a proxy, gateway,</span>
144:               <span class="ruby-comment cmt">#  or other intermediary acting on behalf of the actual source client.&quot;</span>
145:               <span class="ruby-identifier">params</span>[<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">REMOTE_ADDR</span>] = <span class="ruby-identifier">client</span>.<span class="ruby-identifier">peeraddr</span>.<span class="ruby-identifier">last</span>
146: 
147:               <span class="ruby-comment cmt"># select handlers that want more detailed request notification</span>
148:               <span class="ruby-identifier">notifiers</span> = <span class="ruby-identifier">handlers</span>.<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">h</span><span class="ruby-operator">|</span> <span class="ruby-identifier">h</span>.<span class="ruby-identifier">request_notify</span> }
149:               <span class="ruby-identifier">request</span> = <span class="ruby-constant">HttpRequest</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">params</span>, <span class="ruby-identifier">client</span>, <span class="ruby-identifier">notifiers</span>)
150: 
151:               <span class="ruby-comment cmt"># in the case of large file uploads the user could close the socket, so skip those requests</span>
152:               <span class="ruby-keyword kw">break</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">request</span>.<span class="ruby-identifier">body</span> <span class="ruby-operator">==</span> <span class="ruby-keyword kw">nil</span>  <span class="ruby-comment cmt"># nil signals from HttpRequest::initialize that the request was aborted</span>
153: 
154:               <span class="ruby-comment cmt"># request is good so far, continue processing the response</span>
155:               <span class="ruby-identifier">response</span> = <span class="ruby-constant">HttpResponse</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">client</span>)
156: 
157:               <span class="ruby-comment cmt"># Process each handler in registered order until we run out or one finalizes the response.</span>
158:               <span class="ruby-identifier">handlers</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">handler</span><span class="ruby-operator">|</span>
159:                 <span class="ruby-identifier">handler</span>.<span class="ruby-identifier">process</span>(<span class="ruby-identifier">request</span>, <span class="ruby-identifier">response</span>)
160:                 <span class="ruby-keyword kw">break</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">response</span>.<span class="ruby-identifier">done</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">client</span>.<span class="ruby-identifier">closed?</span>
161:               <span class="ruby-keyword kw">end</span>
162: 
163:               <span class="ruby-comment cmt"># And finally, if nobody closed the response off, we finalize it.</span>
164:               <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">response</span>.<span class="ruby-identifier">done</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">client</span>.<span class="ruby-identifier">closed?</span> 
165:                 <span class="ruby-identifier">response</span>.<span class="ruby-identifier">finished</span>
166:               <span class="ruby-keyword kw">end</span>
167:             <span class="ruby-keyword kw">else</span>
168:               <span class="ruby-comment cmt"># Didn't find it, return a stock 404 response.</span>
169:               <span class="ruby-identifier">client</span>.<span class="ruby-identifier">write</span>(<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">ERROR_404_RESPONSE</span>)
170:             <span class="ruby-keyword kw">end</span>
171: 
172:             <span class="ruby-keyword kw">break</span> <span class="ruby-comment cmt">#done</span>
173:           <span class="ruby-keyword kw">else</span>
174:             <span class="ruby-comment cmt"># Parser is not done, queue up more data to read and continue parsing</span>
175:             <span class="ruby-identifier">chunk</span> = <span class="ruby-identifier">client</span>.<span class="ruby-identifier">readpartial</span>(<span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">CHUNK_SIZE</span>)
176:             <span class="ruby-keyword kw">break</span> <span class="ruby-keyword kw">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">chunk</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">chunk</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>  <span class="ruby-comment cmt"># read failed, stop processing</span>
177: 
178:             <span class="ruby-identifier">data</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">chunk</span>
179:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-constant">Const</span><span class="ruby-operator">::</span><span class="ruby-constant">MAX_HEADER</span>
180:               <span class="ruby-identifier">raise</span> <span class="ruby-constant">HttpParserError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value str">&quot;HEADER is longer than allowed, aborting client early.&quot;</span>)
181:             <span class="ruby-keyword kw">end</span>
182:           <span class="ruby-keyword kw">end</span>
183:         <span class="ruby-keyword kw">end</span>
184:       <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">EOFError</span>,<span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">ECONNRESET</span>,<span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">EPIPE</span>,<span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">EINVAL</span>,<span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">EBADF</span>
185:         <span class="ruby-identifier">client</span>.<span class="ruby-identifier">close</span> <span class="ruby-keyword kw">rescue</span> <span class="ruby-keyword kw">nil</span>
186:       <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">HttpParserError</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
187:         <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{Time.now}: HTTP parse error, malformed request (#{params[Const::HTTP_X_FORWARDED_FOR] || client.peeraddr.last}): #{e.inspect}&quot;</span>
188:         <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{Time.now}: REQUEST DATA: #{data.inspect}\n---\nPARAMS: #{params.inspect}\n---\n&quot;</span>
189:       <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">EMFILE</span>
190:         <span class="ruby-identifier">reap_dead_workers</span>(<span class="ruby-value str">'too many files'</span>)
191:       <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">Object</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
192:         <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{Time.now}: Read error: #{e.inspect}&quot;</span>
193:         <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">backtrace</span>.<span class="ruby-identifier">join</span>(<span class="ruby-value str">&quot;\n&quot;</span>)
194:       <span class="ruby-keyword kw">ensure</span>
195:         <span class="ruby-keyword kw">begin</span>
196:           <span class="ruby-identifier">client</span>.<span class="ruby-identifier">close</span>
197:         <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">IOError</span>
198:           <span class="ruby-comment cmt"># Already closed</span>
199:         <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">Object</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
200:           <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{Time.now}: Client error: #{e.inspect}&quot;</span>
201:           <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">backtrace</span>.<span class="ruby-identifier">join</span>(<span class="ruby-value str">&quot;\n&quot;</span>)
202:         <span class="ruby-keyword kw">end</span>
203:         <span class="ruby-identifier">request</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">delete</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">request</span> <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">request</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Tempfile</span>
204:       <span class="ruby-keyword kw">end</span>
205:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000085" class="method-detail">
        <a name="M000085"></a>

        <div class="method-heading">
          <a href="#M000085" class="method-signature">
          <span class="method-name">reap_dead_workers</span><span class="method-args">(reason='unknown')</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Used internally to kill off any worker threads that have taken too long to
complete processing. Only called if there are too many processors currently
servicing. It returns the count of workers still active after the reap is
done. It only runs if there are workers to reap.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000085-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000085-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 211</span>
211:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">reap_dead_workers</span>(<span class="ruby-identifier">reason</span>=<span class="ruby-value str">'unknown'</span>)
212:       <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@workers</span>.<span class="ruby-identifier">list</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
213:         <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{Time.now}: Reaping #{@workers.list.length} threads for slow workers because of '#{reason}'&quot;</span>
214:         <span class="ruby-identifier">error_msg</span> = <span class="ruby-node">&quot;Mongrel timed out this thread: #{reason}&quot;</span>
215:         <span class="ruby-identifier">mark</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
216:         <span class="ruby-ivar">@workers</span>.<span class="ruby-identifier">list</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">worker</span><span class="ruby-operator">|</span>
217:           <span class="ruby-identifier">worker</span>[<span class="ruby-identifier">:started_on</span>] = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span> <span class="ruby-keyword kw">if</span> <span class="ruby-keyword kw">not</span> <span class="ruby-identifier">worker</span>[<span class="ruby-identifier">:started_on</span>]
218: 
219:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">mark</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">worker</span>[<span class="ruby-identifier">:started_on</span>] <span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@timeout</span> <span class="ruby-operator">+</span> <span class="ruby-ivar">@throttle</span>
220:             <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Thread #{worker.inspect} is too old, killing.&quot;</span>
221:             <span class="ruby-identifier">worker</span>.<span class="ruby-identifier">raise</span>(<span class="ruby-constant">TimeoutError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">error_msg</span>))
222:           <span class="ruby-keyword kw">end</span>
223:         <span class="ruby-keyword kw">end</span>
224:       <span class="ruby-keyword kw">end</span>
225: 
226:       <span class="ruby-keyword kw">return</span> <span class="ruby-ivar">@workers</span>.<span class="ruby-identifier">list</span>.<span class="ruby-identifier">length</span>
227:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000094" class="method-detail">
        <a name="M000094"></a>

        <div class="method-heading">
          <a href="#M000094" class="method-signature">
          <span class="method-name">reap_dead_workers</span><span class="method-args">(reason='unknown')</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Used internally to kill off any worker threads that have taken too long to
complete processing. Only called if there are too many processors currently
servicing. It returns the count of workers still active after the reap is
done. It only runs if there are workers to reap.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000094-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000094-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 211</span>
211:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">reap_dead_workers</span>(<span class="ruby-identifier">reason</span>=<span class="ruby-value str">'unknown'</span>)
212:       <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@workers</span>.<span class="ruby-identifier">list</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
213:         <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{Time.now}: Reaping #{@workers.list.length} threads for slow workers because of '#{reason}'&quot;</span>
214:         <span class="ruby-identifier">error_msg</span> = <span class="ruby-node">&quot;Mongrel timed out this thread: #{reason}&quot;</span>
215:         <span class="ruby-identifier">mark</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
216:         <span class="ruby-ivar">@workers</span>.<span class="ruby-identifier">list</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">worker</span><span class="ruby-operator">|</span>
217:           <span class="ruby-identifier">worker</span>[<span class="ruby-identifier">:started_on</span>] = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span> <span class="ruby-keyword kw">if</span> <span class="ruby-keyword kw">not</span> <span class="ruby-identifier">worker</span>[<span class="ruby-identifier">:started_on</span>]
218: 
219:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">mark</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">worker</span>[<span class="ruby-identifier">:started_on</span>] <span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@timeout</span> <span class="ruby-operator">+</span> <span class="ruby-ivar">@throttle</span>
220:             <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Thread #{worker.inspect} is too old, killing.&quot;</span>
221:             <span class="ruby-identifier">worker</span>.<span class="ruby-identifier">raise</span>(<span class="ruby-constant">TimeoutError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">error_msg</span>))
222:           <span class="ruby-keyword kw">end</span>
223:         <span class="ruby-keyword kw">end</span>
224:       <span class="ruby-keyword kw">end</span>
225: 
226:       <span class="ruby-keyword kw">return</span> <span class="ruby-ivar">@workers</span>.<span class="ruby-identifier">list</span>.<span class="ruby-identifier">length</span>
227:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000089" class="method-detail">
        <a name="M000089"></a>

        <div class="method-heading">
          <a href="#M000089" class="method-signature">
          <span class="method-name">register</span><span class="method-args">(uri, handler, in_front=false)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Simply registers a handler with the internal <a
href="URIClassifier.html">URIClassifier</a>. When the URI is found in the
prefix of a request then your handler&#8216;s HttpHandler::process method
is called. See <a
href="URIClassifier.html#M000185">Mongrel::URIClassifier#register</a> for
more information.
</p>
<p>
If you set in_front=true then the passed in handler will be put in the
front of the list for that particular URI. Otherwise it&#8216;s placed at
the end of the list.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000089-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000089-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 320</span>
320:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">register</span>(<span class="ruby-identifier">uri</span>, <span class="ruby-identifier">handler</span>, <span class="ruby-identifier">in_front</span>=<span class="ruby-keyword kw">false</span>)
321:       <span class="ruby-keyword kw">begin</span>
322:         <span class="ruby-ivar">@classifier</span>.<span class="ruby-identifier">register</span>(<span class="ruby-identifier">uri</span>, [<span class="ruby-identifier">handler</span>])
323:       <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">URIClassifier</span><span class="ruby-operator">::</span><span class="ruby-constant">RegistrationError</span>
324:         <span class="ruby-identifier">handlers</span> = <span class="ruby-ivar">@classifier</span>.<span class="ruby-identifier">resolve</span>(<span class="ruby-identifier">uri</span>)[<span class="ruby-value">2</span>]
325:         <span class="ruby-identifier">method_name</span> = <span class="ruby-identifier">in_front</span> <span class="ruby-value">? </span><span class="ruby-value str">'unshift'</span> <span class="ruby-operator">:</span> <span class="ruby-value str">'push'</span>
326:         <span class="ruby-identifier">handlers</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">handler</span>)
327:       <span class="ruby-keyword kw">end</span>
328:       <span class="ruby-identifier">handler</span>.<span class="ruby-identifier">listener</span> = <span class="ruby-keyword kw">self</span>
329:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000098" class="method-detail">
        <a name="M000098"></a>

        <div class="method-heading">
          <a href="#M000098" class="method-signature">
          <span class="method-name">register</span><span class="method-args">(uri, handler, in_front=false)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Simply registers a handler with the internal <a
href="URIClassifier.html">URIClassifier</a>. When the URI is found in the
prefix of a request then your handler&#8216;s HttpHandler::process method
is called. See <a
href="URIClassifier.html#M000185">Mongrel::URIClassifier#register</a> for
more information.
</p>
<p>
If you set in_front=true then the passed in handler will be put in the
front of the list for that particular URI. Otherwise it&#8216;s placed at
the end of the list.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000098-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000098-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 320</span>
320:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">register</span>(<span class="ruby-identifier">uri</span>, <span class="ruby-identifier">handler</span>, <span class="ruby-identifier">in_front</span>=<span class="ruby-keyword kw">false</span>)
321:       <span class="ruby-keyword kw">begin</span>
322:         <span class="ruby-ivar">@classifier</span>.<span class="ruby-identifier">register</span>(<span class="ruby-identifier">uri</span>, [<span class="ruby-identifier">handler</span>])
323:       <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">URIClassifier</span><span class="ruby-operator">::</span><span class="ruby-constant">RegistrationError</span>
324:         <span class="ruby-identifier">handlers</span> = <span class="ruby-ivar">@classifier</span>.<span class="ruby-identifier">resolve</span>(<span class="ruby-identifier">uri</span>)[<span class="ruby-value">2</span>]
325:         <span class="ruby-identifier">method_name</span> = <span class="ruby-identifier">in_front</span> <span class="ruby-value">? </span><span class="ruby-value str">'unshift'</span> <span class="ruby-operator">:</span> <span class="ruby-value str">'push'</span>
326:         <span class="ruby-identifier">handlers</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">handler</span>)
327:       <span class="ruby-keyword kw">end</span>
328:       <span class="ruby-identifier">handler</span>.<span class="ruby-identifier">listener</span> = <span class="ruby-keyword kw">self</span>
329:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000088" class="method-detail">
        <a name="M000088"></a>

        <div class="method-heading">
          <a href="#M000088" class="method-signature">
          <span class="method-name">run</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Runs the thing. It returns the thread used so you can &quot;join&quot; it.
You can also access the HttpServer::acceptor attribute to get the thread
later.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000088-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000088-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 259</span>
259:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">run</span>
260:       <span class="ruby-constant">BasicSocket</span>.<span class="ruby-identifier">do_not_reverse_lookup</span>=<span class="ruby-keyword kw">true</span>
261: 
262:       <span class="ruby-identifier">configure_socket_options</span>
263: 
264:       <span class="ruby-keyword kw">if</span> <span class="ruby-keyword kw">defined?</span>(<span class="ruby-identifier">$tcp_defer_accept_opts</span>) <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">$tcp_defer_accept_opts</span>
265:         <span class="ruby-ivar">@socket</span>.<span class="ruby-identifier">setsockopt</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">$tcp_defer_accept_opts</span>) <span class="ruby-keyword kw">rescue</span> <span class="ruby-keyword kw">nil</span>
266:       <span class="ruby-keyword kw">end</span>
267: 
268:       <span class="ruby-ivar">@acceptor</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword kw">do</span>
269:         <span class="ruby-keyword kw">begin</span>
270:           <span class="ruby-keyword kw">while</span> <span class="ruby-keyword kw">true</span>
271:             <span class="ruby-keyword kw">begin</span>
272:               <span class="ruby-identifier">client</span> = <span class="ruby-ivar">@socket</span>.<span class="ruby-identifier">accept</span>
273:   
274:               <span class="ruby-keyword kw">if</span> <span class="ruby-keyword kw">defined?</span>(<span class="ruby-identifier">$tcp_cork_opts</span>) <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">$tcp_cork_opts</span>
275:                 <span class="ruby-identifier">client</span>.<span class="ruby-identifier">setsockopt</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">$tcp_cork_opts</span>) <span class="ruby-keyword kw">rescue</span> <span class="ruby-keyword kw">nil</span>
276:               <span class="ruby-keyword kw">end</span>
277:   
278:               <span class="ruby-identifier">worker_list</span> = <span class="ruby-ivar">@workers</span>.<span class="ruby-identifier">list</span>
279:   
280:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">worker_list</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-ivar">@num_processors</span>
281:                 <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Server overloaded with #{worker_list.length} processors (#@num_processors max). Dropping connection.&quot;</span>
282:                 <span class="ruby-identifier">client</span>.<span class="ruby-identifier">close</span> <span class="ruby-keyword kw">rescue</span> <span class="ruby-keyword kw">nil</span>
283:                 <span class="ruby-identifier">reap_dead_workers</span>(<span class="ruby-value str">&quot;max processors&quot;</span>)
284:               <span class="ruby-keyword kw">else</span>
285:                 <span class="ruby-identifier">thread</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">client</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">process_client</span>(<span class="ruby-identifier">c</span>) }
286:                 <span class="ruby-identifier">thread</span>[<span class="ruby-identifier">:started_on</span>] = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
287:                 <span class="ruby-ivar">@workers</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">thread</span>)
288:   
289:                 <span class="ruby-identifier">sleep</span> <span class="ruby-ivar">@throttle</span> <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@throttle</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
290:               <span class="ruby-keyword kw">end</span>
291:             <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">StopServer</span>
292:               <span class="ruby-keyword kw">break</span>
293:             <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">EMFILE</span>
294:               <span class="ruby-identifier">reap_dead_workers</span>(<span class="ruby-value str">&quot;too many open files&quot;</span>)
295:               <span class="ruby-identifier">sleep</span> <span class="ruby-value">0</span><span class="ruby-value">.5</span>
296:             <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">ECONNABORTED</span>
297:               <span class="ruby-comment cmt"># client closed the socket even before accept</span>
298:               <span class="ruby-identifier">client</span>.<span class="ruby-identifier">close</span> <span class="ruby-keyword kw">rescue</span> <span class="ruby-keyword kw">nil</span>
299:             <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">Object</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
300:               <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{Time.now}: Unhandled listen loop exception #{e.inspect}.&quot;</span>
301:               <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">backtrace</span>.<span class="ruby-identifier">join</span>(<span class="ruby-value str">&quot;\n&quot;</span>)
302:             <span class="ruby-keyword kw">end</span>
303:           <span class="ruby-keyword kw">end</span>
304:           <span class="ruby-identifier">graceful_shutdown</span>
305:         <span class="ruby-keyword kw">ensure</span>
306:           <span class="ruby-ivar">@socket</span>.<span class="ruby-identifier">close</span>
307:           <span class="ruby-comment cmt"># STDERR.puts &quot;#{Time.now}: Closed socket.&quot;</span>
308:         <span class="ruby-keyword kw">end</span>
309:       <span class="ruby-keyword kw">end</span>
310: 
311:       <span class="ruby-keyword kw">return</span> <span class="ruby-ivar">@acceptor</span>
312:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000097" class="method-detail">
        <a name="M000097"></a>

        <div class="method-heading">
          <a href="#M000097" class="method-signature">
          <span class="method-name">run</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Runs the thing. It returns the thread used so you can &quot;join&quot; it.
You can also access the HttpServer::acceptor attribute to get the thread
later.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000097-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000097-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 259</span>
259:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">run</span>
260:       <span class="ruby-constant">BasicSocket</span>.<span class="ruby-identifier">do_not_reverse_lookup</span>=<span class="ruby-keyword kw">true</span>
261: 
262:       <span class="ruby-identifier">configure_socket_options</span>
263: 
264:       <span class="ruby-keyword kw">if</span> <span class="ruby-keyword kw">defined?</span>(<span class="ruby-identifier">$tcp_defer_accept_opts</span>) <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">$tcp_defer_accept_opts</span>
265:         <span class="ruby-ivar">@socket</span>.<span class="ruby-identifier">setsockopt</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">$tcp_defer_accept_opts</span>) <span class="ruby-keyword kw">rescue</span> <span class="ruby-keyword kw">nil</span>
266:       <span class="ruby-keyword kw">end</span>
267: 
268:       <span class="ruby-ivar">@acceptor</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword kw">do</span>
269:         <span class="ruby-keyword kw">begin</span>
270:           <span class="ruby-keyword kw">while</span> <span class="ruby-keyword kw">true</span>
271:             <span class="ruby-keyword kw">begin</span>
272:               <span class="ruby-identifier">client</span> = <span class="ruby-ivar">@socket</span>.<span class="ruby-identifier">accept</span>
273:   
274:               <span class="ruby-keyword kw">if</span> <span class="ruby-keyword kw">defined?</span>(<span class="ruby-identifier">$tcp_cork_opts</span>) <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">$tcp_cork_opts</span>
275:                 <span class="ruby-identifier">client</span>.<span class="ruby-identifier">setsockopt</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">$tcp_cork_opts</span>) <span class="ruby-keyword kw">rescue</span> <span class="ruby-keyword kw">nil</span>
276:               <span class="ruby-keyword kw">end</span>
277:   
278:               <span class="ruby-identifier">worker_list</span> = <span class="ruby-ivar">@workers</span>.<span class="ruby-identifier">list</span>
279:   
280:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">worker_list</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-ivar">@num_processors</span>
281:                 <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Server overloaded with #{worker_list.length} processors (#@num_processors max). Dropping connection.&quot;</span>
282:                 <span class="ruby-identifier">client</span>.<span class="ruby-identifier">close</span> <span class="ruby-keyword kw">rescue</span> <span class="ruby-keyword kw">nil</span>
283:                 <span class="ruby-identifier">reap_dead_workers</span>(<span class="ruby-value str">&quot;max processors&quot;</span>)
284:               <span class="ruby-keyword kw">else</span>
285:                 <span class="ruby-identifier">thread</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">client</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">process_client</span>(<span class="ruby-identifier">c</span>) }
286:                 <span class="ruby-identifier">thread</span>[<span class="ruby-identifier">:started_on</span>] = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
287:                 <span class="ruby-ivar">@workers</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">thread</span>)
288:   
289:                 <span class="ruby-identifier">sleep</span> <span class="ruby-ivar">@throttle</span> <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@throttle</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
290:               <span class="ruby-keyword kw">end</span>
291:             <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">StopServer</span>
292:               <span class="ruby-keyword kw">break</span>
293:             <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">EMFILE</span>
294:               <span class="ruby-identifier">reap_dead_workers</span>(<span class="ruby-value str">&quot;too many open files&quot;</span>)
295:               <span class="ruby-identifier">sleep</span> <span class="ruby-value">0</span><span class="ruby-value">.5</span>
296:             <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">ECONNABORTED</span>
297:               <span class="ruby-comment cmt"># client closed the socket even before accept</span>
298:               <span class="ruby-identifier">client</span>.<span class="ruby-identifier">close</span> <span class="ruby-keyword kw">rescue</span> <span class="ruby-keyword kw">nil</span>
299:             <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">Object</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
300:               <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{Time.now}: Unhandled listen loop exception #{e.inspect}.&quot;</span>
301:               <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">puts</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">backtrace</span>.<span class="ruby-identifier">join</span>(<span class="ruby-value str">&quot;\n&quot;</span>)
302:             <span class="ruby-keyword kw">end</span>
303:           <span class="ruby-keyword kw">end</span>
304:           <span class="ruby-identifier">graceful_shutdown</span>
305:         <span class="ruby-keyword kw">ensure</span>
306:           <span class="ruby-ivar">@socket</span>.<span class="ruby-identifier">close</span>
307:           <span class="ruby-comment cmt"># STDERR.puts &quot;#{Time.now}: Closed socket.&quot;</span>
308:         <span class="ruby-keyword kw">end</span>
309:       <span class="ruby-keyword kw">end</span>
310: 
311:       <span class="ruby-keyword kw">return</span> <span class="ruby-ivar">@acceptor</span>
312:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000091" class="method-detail">
        <a name="M000091"></a>

        <div class="method-heading">
          <a href="#M000091" class="method-signature">
          <span class="method-name">stop</span><span class="method-args">(synchronous=false)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Stops the acceptor thread and then causes the worker threads to finish off
the request queue before finally exiting.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000091-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000091-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 340</span>
340:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">stop</span>(<span class="ruby-identifier">synchronous</span>=<span class="ruby-keyword kw">false</span>)
341:       <span class="ruby-ivar">@acceptor</span>.<span class="ruby-identifier">raise</span>(<span class="ruby-constant">StopServer</span>.<span class="ruby-identifier">new</span>)
342: 
343:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">synchronous</span>
344:         <span class="ruby-identifier">sleep</span>(<span class="ruby-value">0</span><span class="ruby-value">.5</span>) <span class="ruby-keyword kw">while</span> <span class="ruby-ivar">@acceptor</span>.<span class="ruby-identifier">alive?</span>
345:       <span class="ruby-keyword kw">end</span>
346:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000100" class="method-detail">
        <a name="M000100"></a>

        <div class="method-heading">
          <a href="#M000100" class="method-signature">
          <span class="method-name">stop</span><span class="method-args">(synchronous=false)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Stops the acceptor thread and then causes the worker threads to finish off
the request queue before finally exiting.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000100-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000100-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 340</span>
340:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">stop</span>(<span class="ruby-identifier">synchronous</span>=<span class="ruby-keyword kw">false</span>)
341:       <span class="ruby-ivar">@acceptor</span>.<span class="ruby-identifier">raise</span>(<span class="ruby-constant">StopServer</span>.<span class="ruby-identifier">new</span>)
342: 
343:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">synchronous</span>
344:         <span class="ruby-identifier">sleep</span>(<span class="ruby-value">0</span><span class="ruby-value">.5</span>) <span class="ruby-keyword kw">while</span> <span class="ruby-ivar">@acceptor</span>.<span class="ruby-identifier">alive?</span>
345:       <span class="ruby-keyword kw">end</span>
346:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000090" class="method-detail">
        <a name="M000090"></a>

        <div class="method-heading">
          <a href="#M000090" class="method-signature">
          <span class="method-name">unregister</span><span class="method-args">(uri)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Removes any handlers registered at the given URI. See <a
href="URIClassifier.html#M000186">Mongrel::URIClassifier#unregister</a> for
more information. Remember this removes them <b>all</b> so the entire
processing chain goes away.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000090-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000090-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 334</span>
334:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">unregister</span>(<span class="ruby-identifier">uri</span>)
335:       <span class="ruby-ivar">@classifier</span>.<span class="ruby-identifier">unregister</span>(<span class="ruby-identifier">uri</span>)
336:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000099" class="method-detail">
        <a name="M000099"></a>

        <div class="method-heading">
          <a href="#M000099" class="method-signature">
          <span class="method-name">unregister</span><span class="method-args">(uri)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Removes any handlers registered at the given URI. See <a
href="URIClassifier.html#M000186">Mongrel::URIClassifier#unregister</a> for
more information. Remember this removes them <b>all</b> so the entire
processing chain goes away.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000099-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000099-source">
<pre>
     <span class="ruby-comment cmt"># File lib/mongrel.rb, line 334</span>
334:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">unregister</span>(<span class="ruby-identifier">uri</span>)
335:       <span class="ruby-ivar">@classifier</span>.<span class="ruby-identifier">unregister</span>(<span class="ruby-identifier">uri</span>)
336:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>