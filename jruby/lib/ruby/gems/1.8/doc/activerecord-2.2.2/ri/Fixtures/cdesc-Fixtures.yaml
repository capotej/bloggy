--- !ruby/object:RI::ClassDescription 
includes: []

comment: 
- !ruby/struct:SM::Flow::P 
  body: 'Fixtures are a way of organizing data that you want to test against; in short,
    sample data. They come in 3 flavors:'
- !ruby/struct:SM::Flow::VERB 
  body: "  1.  YAML fixtures\n  2.  CSV fixtures\n  3.  Single-file fixtures\n"
- !ruby/struct:SM::Flow::H 
  text: YAML fixtures
  level: 1
- !ruby/struct:SM::Flow::P 
  body: This type of fixture is in YAML format and the preferred default. YAML is
    a file format which describes data structures in a non-verbose, human-readable
    format. It ships with Ruby 1.8.1+.
- !ruby/struct:SM::Flow::P 
  body: 'Unlike single-file fixtures, YAML fixtures are stored in a single file per
    model, which are placed in the directory appointed by <tt>ActiveSupport::TestCase.fixture_path=(path)</tt>
    (this is automatically configured for Rails, so you can just put your files in
    <tt>&lt;your-rails-app&gt;/test/fixtures/</tt>). The fixture file ends with the
    <tt>.yml</tt> file extension (Rails example: <tt>&lt;your-rails-app&gt;/test/fixtures/web_sites.yml</tt>).
    The format of a YAML fixture file looks like this:'
- !ruby/struct:SM::Flow::VERB 
  body: "  rubyonrails:\n    id: 1\n    name: Ruby on Rails\n    url: http://www.rubyonrails.org\n\
    \n  google:\n    id: 2\n    name: Google\n    url: http://www.google.com\n"
- !ruby/struct:SM::Flow::P 
  body: 'This YAML fixture file includes two fixtures. Each YAML fixture (ie. record)
    is given a name and is followed by an indented list of key/value pairs in the
    &quot;key: value&quot; format. Records are separated by a blank line for your
    viewing pleasure.'
- !ruby/struct:SM::Flow::P 
  body: 'Note that YAML fixtures are unordered. If you want ordered fixtures, use
    the omap YAML type. See http://yaml.org/type/omap.html for the specification.
    You will need ordered fixtures when you have foreign key constraints on keys in
    the same table. This is commonly needed for tree structures. Example:'
- !ruby/struct:SM::Flow::VERB 
  body: "   --- !omap\n   - parent:\n       id:         1\n       parent_id:  NULL\n\
    \       title:      Parent\n   - child:\n       id:         2\n       parent_id: \
    \ 1\n       title:      Child\n"
- !ruby/struct:SM::Flow::H 
  text: CSV fixtures
  level: 1
- !ruby/struct:SM::Flow::P 
  body: 'Fixtures can also be kept in the Comma Separated Value format. Akin to YAML
    fixtures, CSV fixtures are stored in a single file, but instead end with the <tt>.csv</tt>
    file extension (Rails example: <tt>&lt;your-rails-app&gt;/test/fixtures/web_sites.csv</tt>).'
- !ruby/struct:SM::Flow::P 
  body: 'The format of this type of fixture file is much more compact than the others,
    but also a little harder to read by us humans. The first line of the CSV file
    is a comma-separated list of field names. The rest of the file is then comprised
    of the actual data (1 per line). Here''s an example:'
- !ruby/struct:SM::Flow::VERB 
  body: "  id, name, url\n  1, Ruby On Rails, http://www.rubyonrails.org\n  2, Google, \
    http://www.google.com\n"
- !ruby/struct:SM::Flow::P 
  body: Should you have a piece of data with a comma character in it, you can place
    double quotes around that value. If you need to use a double quote character,
    you must escape it with another double quote.
- !ruby/struct:SM::Flow::P 
  body: Another unique attribute of the CSV fixture is that it has <b>no</b> fixture
    name like the other two formats. Instead, the fixture names are automatically
    generated by deriving the class name of the fixture file and adding an incrementing
    number to the end. In our example, the 1st fixture would be called &quot;web_site_1&quot;
    and the 2nd one would be called &quot;web_site_2&quot;.
- !ruby/struct:SM::Flow::P 
  body: Most databases and spreadsheets support exporting to CSV format, so this is
    a great format for you to choose if you have existing data somewhere already.
- !ruby/struct:SM::Flow::H 
  text: Single-file fixtures
  level: 1
- !ruby/struct:SM::Flow::P 
  body: This type of fixture was the original format for Active Record that has since
    been deprecated in favor of the YAML and CSV formats. Fixtures for this format
    are created by placing text files in a sub-directory (with the name of the model)
    to the directory appointed by <tt>ActiveSupport::TestCase.fixture_path=(path)</tt>
    (this is automatically configured for Rails, so you can just put your files in
    <tt>&lt;your-rails-app&gt;/test/fixtures/&lt;your-model-name&gt;/</tt> -- like
    <tt>&lt;your-rails-app&gt;/test/fixtures/web_sites/</tt> for the WebSite model).
- !ruby/struct:SM::Flow::P 
  body: 'Each text file placed in this directory represents a &quot;record&quot;.
    Usually these types of fixtures are named without extensions, but if you are on
    a Windows machine, you might consider adding <tt>.txt</tt> as the extension. Here''s
    what the above example might look like:'
- !ruby/struct:SM::Flow::VERB 
  body: "  web_sites/google\n  web_sites/yahoo.txt\n  web_sites/ruby-on-rails\n"
- !ruby/struct:SM::Flow::P 
  body: 'The file format of a standard fixture is simple. Each line is a property
    (or column in db speak) and has the syntax of &quot;name =&gt; value&quot;. Here''s
    an example of the ruby-on-rails fixture above:'
- !ruby/struct:SM::Flow::VERB 
  body: "  id =&gt; 1\n  name =&gt; Ruby on Rails\n  url =&gt; http://www.rubyonrails.org\n"
- !ruby/struct:SM::Flow::H 
  text: Using Fixtures
  level: 1
- !ruby/struct:SM::Flow::P 
  body: 'Since fixtures are a testing construct, we use them in our unit and functional
    tests. There are two ways to use the fixtures, but first let''s take a look at
    a sample unit test:'
- !ruby/struct:SM::Flow::VERB 
  body: "  require 'web_site'\n\n  class WebSiteTest &lt; ActiveSupport::TestCase\n\
    \    def test_web_site_count\n      assert_equal 2, WebSite.count\n    end\n  end\n"
- !ruby/struct:SM::Flow::P 
  body: 'As it stands, unless we pre-load the web_site table in our database with
    two records, this test will fail. Here''s the easiest way to add fixtures to the
    database:'
- !ruby/struct:SM::Flow::VERB 
  body: "  ...\n  class WebSiteTest &lt; ActiveSupport::TestCase\n    fixtures :web_sites \
    # add more by separating the symbols with commas\n  ...\n"
- !ruby/struct:SM::Flow::P 
  body: By adding a &quot;fixtures&quot; method to the test case and passing it a
    list of symbols (only one is shown here though), we trigger the testing environment
    to automatically load the appropriate fixtures into the database before each test.
    To ensure consistent data, the environment deletes the fixtures before running
    the load.
- !ruby/struct:SM::Flow::P 
  body: In addition to being available in the database, the fixtures are also loaded
    into a hash stored in an instance variable of the test case. It is named after
    the symbol... so, in our example, there would be a hash available called <tt>@web_sites</tt>.
    This is where the &quot;fixture name&quot; comes into play.
- !ruby/struct:SM::Flow::P 
  body: 'On top of that, each record is automatically &quot;found&quot; (using <tt>Model.find(id)</tt>)
    and placed in the instance variable of its name. So for the YAML fixtures, we''d
    get <tt>@rubyonrails</tt> and <tt>@google</tt>, which could be interrogated using
    regular Active Record semantics:'
- !ruby/struct:SM::Flow::VERB 
  body: "  # test if the object created from the fixture data has the same attributes \
    as the data itself\n  def test_find\n    assert_equal @web_sites[&quot;rubyonrails&quot;][&quot;name&quot;], \
    @rubyonrails.name\n  end\n"
- !ruby/struct:SM::Flow::P 
  body: As seen above, the data hash created from the YAML fixtures would have <tt>@web_sites[&quot;rubyonrails&quot;][&quot;url&quot;]</tt>
    return &quot;http://www.rubyonrails.org&quot; and <tt>@web_sites[&quot;google&quot;][&quot;name&quot;]</tt>
    would return &quot;Google&quot;. The same fixtures, but loaded from a CSV fixture
    file, would be accessible via <tt>@web_sites[&quot;web_site_1&quot;][&quot;name&quot;]
    == &quot;Ruby on Rails&quot;</tt> and have the individual fixtures available as
    instance variables <tt>@web_site_1</tt> and <tt>@web_site_2</tt>.
- !ruby/struct:SM::Flow::P 
  body: If you do not wish to use instantiated fixtures (usually for performance reasons)
    there are two options.
- !ruby/struct:SM::Flow::VERB 
  body: "  - to completely disable instantiated fixtures:\n      self.use_instantiated_fixtures \
    = false\n\n  - to keep the fixture instance (@web_sites) available, but do not \
    automatically 'find' each instance:\n      self.use_instantiated_fixtures = :no_instances\n"
- !ruby/struct:SM::Flow::P 
  body: 'Even if auto-instantiated fixtures are disabled, you can still access them
    by name via special dynamic methods. Each method has the same name as the model,
    and accepts the name of the fixture to instantiate:'
- !ruby/struct:SM::Flow::VERB 
  body: "  fixtures :web_sites\n\n  def test_find\n    assert_equal &quot;Ruby on \
    Rails&quot;, web_sites(:rubyonrails).name\n  end\n"
- !ruby/struct:SM::Flow::H 
  text: Dynamic fixtures with ERb
  level: 1
- !ruby/struct:SM::Flow::P 
  body: 'Some times you don''t care about the content of the fixtures as much as you
    care about the volume. In these cases, you can mix ERb in with your YAML or CSV
    fixtures to create a bunch of fixtures for load testing, like:'
- !ruby/struct:SM::Flow::VERB 
  body: "  &lt;% for i in 1..1000 %&gt;\n  fix_&lt;%= i %&gt;:\n    id: &lt;%= i %&gt;\n\
    \    name: guy_&lt;%= 1 %&gt;\n  &lt;% end %&gt;\n"
- !ruby/struct:SM::Flow::P 
  body: This will create 1000 very simple YAML fixtures.
- !ruby/struct:SM::Flow::P 
  body: Using ERb, you can also inject dynamic values into your fixtures with inserts
    like <tt>&lt;%= Date.today.strftime(&quot;%Y-%m-%d&quot;) %&gt;</tt>. This is
    however a feature to be used with some caution. The point of fixtures are that
    they're stable units of predictable sample data. If you feel that you need to
    inject dynamic values, then perhaps you should reexamine whether your application
    is properly testable. Hence, dynamic values in fixtures are to be considered a
    code smell.
- !ruby/struct:SM::Flow::H 
  text: Transactional fixtures
  level: 1
- !ruby/struct:SM::Flow::P 
  body: TestCases can use begin+rollback to isolate their changes to the database
    instead of having to delete+insert for every test case. They can also turn off
    auto-instantiation of fixture data since the feature is costly and often unused.
- !ruby/struct:SM::Flow::VERB 
  body: "  class FooTest &lt; ActiveSupport::TestCase\n    self.use_transactional_fixtures \
    = true\n    self.use_instantiated_fixtures = false\n\n    fixtures :foos\n\n  \
    \  def test_godzilla\n      assert !Foo.find(:all).empty?\n      Foo.destroy_all\n\
    \      assert Foo.find(:all).empty?\n    end\n\n    def test_godzilla_aftermath\n\
    \      assert !Foo.find(:all).empty?\n    end\n  end\n"
- !ruby/struct:SM::Flow::P 
  body: If you preload your test database with all fixture data (probably in the Rakefile
    task) and use transactional fixtures, then you may omit all fixtures declarations
    in your test cases since all the data's already there and every case rolls back
    its changes.
- !ruby/struct:SM::Flow::P 
  body: In order to use instantiated fixtures with preloaded data, set +self.pre_loaded_fixtures+
    to true. This will provide access to fixture data for every table that has been
    loaded through fixtures (depending on the value of <tt>use_instantiated_fixtures</tt>)
- !ruby/struct:SM::Flow::P 
  body: 'When <b>not</b> to use transactional fixtures:'
- !ruby/struct:SM::Flow::VERB 
  body: "  1. You're testing whether a transaction works correctly. Nested transactions \
    don't commit until all parent transactions commit,\n     particularly, the fixtures \
    transaction which is begun in setup and rolled back in teardown. Thus, you won't \
    be able to verify\n     the results of your transaction until Active Record supports \
    nested transactions or savepoints (in progress).\n  2. Your database does not \
    support transactions. Every Active Record database supports transactions except \
    MySQL MyISAM.\n     Use InnoDB, MaxDB, or NDB instead.\n"
- !ruby/struct:SM::Flow::H 
  text: Advanced YAML Fixtures
  level: 1
- !ruby/struct:SM::Flow::P 
  body: 'YAML fixtures that don''t specify an ID get some extra features:'
- !ruby/object:SM::Flow::LIST 
  type: :BULLET
  contents: 
  - !ruby/struct:SM::Flow::LI 
    body: Stable, autogenerated ID's
    label: '*'
  - !ruby/struct:SM::Flow::LI 
    body: Label references for associations (belongs_to, has_one, has_many)
    label: '*'
  - !ruby/struct:SM::Flow::LI 
    body: HABTM associations as inline lists
    label: '*'
  - !ruby/struct:SM::Flow::LI 
    body: Autofilled timestamp columns
    label: '*'
  - !ruby/struct:SM::Flow::LI 
    body: Fixture label interpolation
    label: '*'
  - !ruby/struct:SM::Flow::LI 
    body: Support for YAML defaults
    label: '*'
- !ruby/struct:SM::Flow::H 
  text: Stable, autogenerated ID's
  level: 2
- !ruby/struct:SM::Flow::P 
  body: 'Here, have a monkey fixture:'
- !ruby/struct:SM::Flow::VERB 
  body: "  george:\n    id: 1\n    name: George the Monkey\n\n  reginald:\n    id: \
    2\n    name: Reginald the Pirate\n"
- !ruby/struct:SM::Flow::P 
  body: 'Each of these fixtures has two unique identifiers: one for the database and
    one for the humans. Why don''t we generate the primary key instead? Hashing each
    fixture''s label yields a consistent ID:'
- !ruby/struct:SM::Flow::VERB 
  body: "  george: # generated id: 503576764\n    name: George the Monkey\n\n  reginald: \
    # generated id: 324201669\n    name: Reginald the Pirate\n"
- !ruby/struct:SM::Flow::P 
  body: Active Record looks at the fixture's model class, discovers the correct primary
    key, and generates it right before inserting the fixture into the database.
- !ruby/struct:SM::Flow::P 
  body: The generated ID for a given label is constant, so we can discover any fixture's
    ID without loading anything, as long as we know the label.
- !ruby/struct:SM::Flow::H 
  text: Label references for associations (belongs_to, has_one, has_many)
  level: 2
- !ruby/struct:SM::Flow::P 
  body: Specifying foreign keys in fixtures can be very fragile, not to mention difficult
    to read. Since Active Record can figure out the ID of any fixture from its label,
    you can specify FK's by label instead of ID.
- !ruby/struct:SM::Flow::H 
  text: belongs_to
  level: 3
- !ruby/struct:SM::Flow::P 
  body: Let's break out some more monkeys and pirates.
- !ruby/struct:SM::Flow::VERB 
  body: "  ### in pirates.yml\n\n  reginald:\n    id: 1\n    name: Reginald the Pirate\n\
    \    monkey_id: 1\n\n  ### in monkeys.yml\n\n  george:\n    id: 1\n    name: George \
    the Monkey\n    pirate_id: 1\n"
- !ruby/struct:SM::Flow::P 
  body: 'Add a few more monkeys and pirates and break this into multiple files, and
    it gets pretty hard to keep track of what''s going on. Let''s use labels instead
    of ID''s:'
- !ruby/struct:SM::Flow::VERB 
  body: "  ### in pirates.yml\n\n  reginald:\n    name: Reginald the Pirate\n    monkey: \
    george\n\n  ### in monkeys.yml\n\n  george:\n    name: George the Monkey\n    \
    pirate: reginald\n"
- !ruby/struct:SM::Flow::P 
  body: 'Pow! All is made clear. Active Record reflects on the fixture''s model class,
    finds all the <tt>belongs_to</tt> associations, and allows you to specify a target
    <b>label</b> for the <b>association</b> (monkey: george) rather than a target
    <b>id</b> for the <b>FK</b> (<tt>monkey_id: 1</tt>).'
- !ruby/struct:SM::Flow::H 
  text: Polymorphic belongs_to
  level: 4
- !ruby/struct:SM::Flow::P 
  body: 'Supporting polymorphic relationships is a little bit more complicated, since
    Active Record needs to know what type your association is pointing at. Something
    like this should look familiar:'
- !ruby/struct:SM::Flow::VERB 
  body: "  ### in fruit.rb\n\n  belongs_to :eater, :polymorphic =&gt; true\n\n  ### \
    in fruits.yml\n\n  apple:\n    id: 1\n    name: apple\n    eater_id: 1\n    eater_type: \
    Monkey\n"
- !ruby/struct:SM::Flow::P 
  body: Can we do better? You bet!
- !ruby/struct:SM::Flow::VERB 
  body: "  apple:\n    eater: george (Monkey)\n"
- !ruby/struct:SM::Flow::P 
  body: Just provide the polymorphic target type and Active Record will take care
    of the rest.
- !ruby/struct:SM::Flow::H 
  text: has_and_belongs_to_many
  level: 3
- !ruby/struct:SM::Flow::P 
  body: Time to give our monkey some fruit.
- !ruby/struct:SM::Flow::VERB 
  body: "  ### in monkeys.yml\n\n  george:\n    id: 1\n    name: George the Monkey\n\
    \    pirate_id: 1\n\n  ### in fruits.yml\n\n  apple:\n    id: 1\n    name: apple\n\
    \n  orange:\n    id: 2\n    name: orange\n\n  grape:\n    id: 3\n    name: grape\n\
    \n  ### in fruits_monkeys.yml\n\n  apple_george:\n    fruit_id: 1\n    monkey_id: \
    1\n\n  orange_george:\n    fruit_id: 2\n    monkey_id: 1\n\n  grape_george:\n\
    \    fruit_id: 3\n    monkey_id: 1\n"
- !ruby/struct:SM::Flow::P 
  body: Let's make the HABTM fixture go away.
- !ruby/struct:SM::Flow::VERB 
  body: "  ### in monkeys.yml\n\n  george:\n    name: George the Monkey\n    pirate: \
    reginald\n    fruits: apple, orange, grape\n\n  ### in fruits.yml\n\n  apple:\n\
    \    name: apple\n\n  orange:\n    name: orange\n\n  grape:\n    name: grape\n"
- !ruby/struct:SM::Flow::P 
  body: Zap! No more fruits_monkeys.yml file. We've specified the list of fruits on
    George's fixture, but we could've just as easily specified a list of monkeys on
    each fruit. As with <tt>belongs_to</tt>, Active Record reflects on the fixture's
    model class and discovers the <tt>has_and_belongs_to_many</tt> associations.
- !ruby/struct:SM::Flow::H 
  text: Autofilled timestamp columns
  level: 2
- !ruby/struct:SM::Flow::P 
  body: If your table/model specifies any of Active Record's standard timestamp columns
    (<tt>created_at</tt>, <tt>created_on</tt>, <tt>updated_at</tt>, <tt>updated_on</tt>),
    they will automatically be set to <tt>Time.now</tt>.
- !ruby/struct:SM::Flow::P 
  body: If you've set specific values, they'll be left alone.
- !ruby/struct:SM::Flow::H 
  text: Fixture label interpolation
  level: 2
- !ruby/struct:SM::Flow::P 
  body: 'The label of the current fixture is always available as a column value:'
- !ruby/struct:SM::Flow::VERB 
  body: "  geeksomnia:\n    name: Geeksomnia's Account\n    subdomain: $LABEL\n"
- !ruby/struct:SM::Flow::P 
  body: 'Also, sometimes (like when porting older join table fixtures) you''ll need
    to be able to get ahold of the identifier for a given label. ERB to the rescue:'
- !ruby/struct:SM::Flow::VERB 
  body: "  george_reginald:\n    monkey_id: &lt;%= Fixtures.identify(:reginald) %&gt;\n\
    \    pirate_id: &lt;%= Fixtures.identify(:george) %&gt;\n"
- !ruby/struct:SM::Flow::H 
  text: Support for YAML defaults
  level: 2
- !ruby/struct:SM::Flow::P 
  body: 'You probably already know how to use YAML to set and reuse defaults in your
    <tt>database.yml</tt> file. You can use the same technique in your fixtures:'
- !ruby/struct:SM::Flow::VERB 
  body: "  DEFAULTS: &amp;DEFAULTS\n    created_on: &lt;%= 3.weeks.ago.to_s(:db) %&gt;\n\
    \n  first:\n    name: Smurf\n    &lt;&lt;: *DEFAULTS\n\n  second:\n    name: Fraggle\n\
    \    &lt;&lt;: *DEFAULTS\n"
- !ruby/struct:SM::Flow::P 
  body: Any fixture labeled &quot;DEFAULTS&quot; is safely ignored.
attributes: 
- !ruby/object:RI::Attribute 
  comment: 
  rw: R
  name: name
- !ruby/object:RI::Attribute 
  comment: 
  rw: R
  name: table_name
instance_methods: 
- !ruby/object:RI::MethodSummary 
  name: delete_existing_fixtures
- !ruby/object:RI::MethodSummary 
  name: insert_fixtures
class_methods: 
- !ruby/object:RI::MethodSummary 
  name: cache_fixtures
- !ruby/object:RI::MethodSummary 
  name: cache_for_connection
- !ruby/object:RI::MethodSummary 
  name: cached_fixtures
- !ruby/object:RI::MethodSummary 
  name: create_fixtures
- !ruby/object:RI::MethodSummary 
  name: fixture_is_cached?
- !ruby/object:RI::MethodSummary 
  name: identify
- !ruby/object:RI::MethodSummary 
  name: instantiate_all_loaded_fixtures
- !ruby/object:RI::MethodSummary 
  name: instantiate_fixtures
- !ruby/object:RI::MethodSummary 
  name: new
- !ruby/object:RI::MethodSummary 
  name: reset_cache
full_name: Fixtures
constants: 
- !ruby/object:RI::Constant 
  comment: 
  value: /\.ya?ml$/
  name: DEFAULT_FILTER_RE
superclass: '(RUBY_VERSION < ''1.9'' ? YAML::Omap : Hash)'
name: Fixtures
